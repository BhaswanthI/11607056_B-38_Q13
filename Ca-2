#include<stdio.h>
#include<unistd.h>

struct process
{
    int priority;
    int burst_time;
    bool executed = False;
};

struct queues
{
    int priority_start;
    int priority_end;
    int length = 0;
    process *p;
    bool executed = False;
};

void notComplete(queues q[])
{
       for(int i=0;i<3;i++)
       {
            for(int j=0;j<q[i].length;j++)
             {
                if(q[i].p[j].burst_time != 0)
                 {
                    return true;
                 }
              }
        }
        return false;
}

void shuffleQueuesOrder(queues q[])
  {
    queues temp;
    for(int i=0;i<2;i++)
     {
        temp = q[i];
        q[i] = q[i+1];
        q[i+1] = temp;
     }
}

void processNotComplete(queues q[])  
 { 
    if(q.p[0].burst_time != 0)
     {
       return true;
     } 
    return false;
}

void sort_rr(process *temp)
{
}
main()
{

    queues q[3];
    q[0].priority_start = 1;
    q[0].priority_end = 3;
    q[1].priority_start = 4;
    q[1].priority_end = 6;
    q[2].priority_start = 7;
    q[2].priority_end = 9;

   int no_of_processes,priority_of_process,burst_time_of_process; 
     printf("enter number of processes");                 
    scanf("%d",&no_of_processes");
    process p1[no_of_processes];

    for(int i=0;i<no_of_processes;i++)
     {
        printf("Enter the priority of the process\n");
        sscanf("%d",&priority_of_process);
        printf("Enter the burst time of the process\n");
        scanf("%d",&burst_time_of_process);
        p1[i].priority = priority_of_process;
        p1[i].burst_time = burst_time_of_process;
      for(int j=0;j<3;j++) 
       {
             							if(q[j].priority_start<=priority_of_process&&priority_of_process<=q[j].priority_end){                          
            q[j].length++;
        }
      }
    }

    for(int i =0;i<3;i++)
     {
        int len = q[i].length;
        q[i].p = new process[len];
     }

 int a=0;
    int b=0;
    int c=0;

    for(int i =0;i<3;i++)
      {
        for(int j=0;j<no_of_processes;j++)
          {
            if((q[i].priority_start<=p1[j].priority) && (p1[j].priority<=q[i].priority_end))
              {
                if(i==0)
                  {
                    q[i].p[a++] = p1[j];

                    }
                else if(i==1)
                    {
                    q[i].p[b++] = p1[j];
                    }
                else
                    {
                    q[i].p[c++] = p1[j];
                    }
            }
        }
    }

    a--;
    b--;
    c--;
    for(int i=0;i<3;i++)
       {
        printf("Queue%d",i+1);
        
        for(int j=0;j<q[i].length;j++)
         {
            printf(q[i].p[j].priority<<"->";
         }
        printf("NULL\n");
    }


    int timer = 0;
    int l =0;
    while(notComplete(q))
      {

         if(timer == 10)
          {
            l+=1;
             if(l>=3)
              {
                l=l%3;
               } 
        }
        if(q[l].executed == true){
            l+=1;
            if(l>=3)
             {
                l=l%3;
             }
            continue;
        }

                if(l==0) 
          {
            int rr_timer = 4;
            while(processNotComplete(q[0])){
              while(rr_timer!=0 || timer!= 10||processNotComplete(q)) 
                  {
                    q[0].p[0].burst_time--;
                    rr_timer--;
                    timer++;
                    }
                if(timer==10)
                 {
                    break;
                 }
                if(rr_timer!=0) 
                  {
                    q[0].p[0].executed = true;
                    
                    sort_rr(q[0].p);                }
                    else if(rr_timer==0 && processNotComplete(q)){
                     sort_rr(q[0].p);

                }
            }
        }

        else if(l==1)
{


 //Priority Scheduling

        }
        else
         {
            //FCFS
        }
    }
}
